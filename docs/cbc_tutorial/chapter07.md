
# 基本处理

在llvm中，本身提供了比较完善的类型支持。但是，这里的实现中，并没有在类型AST中，直接引用llvm中定义的类型，而是在编译前端自身维护了一套类型系统，这和clang的实现方式一致。这么做的原因如下：

- opaque ptr问题。
  
  llvm在定义IR时，针对指针类型的变量，老版本中会显式指定指针指向的类型。比如这样：
  ```
    define i32 @test(i32* %p) {
      store i32 0, i32* %p
      %bc = bitcast i32* %p to i64*
      %v = load i64, i64* %bc
      ret i64 %v
    }
  ```
  但是后来，llvm项目组发现，使用显式类型的指针并没有多少带来多少收益。反而会因为指针类型的不一致会导致很多不必要的转换操作（上面的示例中，将一个i32的值转成i64，还要走一遍指针的类型转换），而且这个指针间的转换太不直观，容易忽略从而导致出现BUG，并且也不好支持优化...
  
  总而言之，在未来版本的LLVM中，IR会逐步使用无类型指针（opaque ptr）替代显式类型的指针。  
  在目前使用的15版本，opaque ptr是默认启用的，显式类型指针仍然支持，但是处于不维护状态了。  
  
  也就是说，现在从llvm后端拿到的指针类型，是无法记录指针指向的类型的，这样对于前端来讲是不可接受的。出于这样的考虑，我们只能在前端维护指针的这些信息。  
  
> 关于opaque ptr更多信息：https://releases.llvm.org/15.0.0/docs/OpaquePointers.html

- 对const和volatile的支持  
  现在并未支持const类型，但是不支持的主要原因是初始化列表的解析不好解决，并非无法支持const的限制修改能力。为了支持const的能力，这里需要在编译前端记录这样的信息，在尝试修改时抛出错误。而llvm后端是无法记录这样的信息的。这里也只能在前端做记录。  
  
- 可扩展性  
  如果需要针对类型增加更多的特性，直接去改llvm是不现实的，所以也只能通过前端维护类型信息，后续的迭代基于前端自己的数据结构进行。  

# 类型支持

这里支持的类型包括：

基本类型：
bool：长度1的整形
(unsigned) char：长度8的整形
(unsigned) short：长度16的整形
(unsigned) int: 长度32的整形，unsigned不带后缀时也是此类型
(unsigned) long: 长度64整形

float：单精度浮点数
double：双精度浮点数

void：只能用于函数（不支持参数使用void）

指针类型
数组类型
结构体类型
函数类型
