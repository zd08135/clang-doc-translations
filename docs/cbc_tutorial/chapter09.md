
# 变量

现在，可以定义基本类型的变量了。  


变量分为局部变量和全局变量。  
我们先考虑局部变量的实现。

# 局部变量

如果用clang编译C语言代码，生成ir时，会看到有很多的alloca指令：
```
Function Attrs: noinline nounwind optnone uwtable
define dso_local i32 @my_function(i32 noundef %0, i32 noundef %1) #0 {
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  ...
```
> https://releases.llvm.org/15.0.0/docs/LangRef.html#alloca-instruction

alloca的作用是在当前执行函数的栈帧上分配空间，这些空间在函数执行结束返回给调用者时自动释放。  
可以用alloca分配的空间来作为局部变量。  

alloca的作用十分强大，除了基本类型之外，数组/指针/结构体等都可以用alloca指令分配。  
这里先看针对基本类型的局部变量的分配。  

创建alloca的接口如下：
```
AllocaInst *CreateAlloca(Type *Ty, Value *ArraySize = nullptr,
                           const Twine &Name = "");
```

CreateAlloca实际上是分配了一个空间，返回指向该空间的指针，对应的值的类型为PointerType

- Ty: 变量类型
- ArraySize：只能传一个IntegerType的Value值，这个参数没啥用。实际上ArrayType本身就有size，传指定值的ArrayType就可以正确分配。  
- Name：这里有一个误解就是这里必须传变量的名字。实际上这里传的值只是一个指示性的作用。变量和名字的关联是由前端自己解决的。如果看clang的ir，这里就没有名字。不过为了方便调试，我们在调用时，会传入变量的名字。  


# 注意事项

## 函数参数的处理

关于函数的参数要注意。在代码中，访问入参时，是假定了这个变量也在栈帧中有空间的。  
（回忆一下汇编语言提到函数调用时，会有将入参压入栈帧的操作）  
比如
```
void func(int x, int y) {
    x = 10;
    y = 5;
    ...
}
```
所以，在函数中，参数等同于一个被传入的值初始化的局部变量。  
在调用时，只是传了值进来，也就是说，我们必须在函数中，为函数的参数也用alloca分配空间，然后把入参的值，使用store保存到空间中，才能正常使用。  

在生成函数代码时，要针对函数的入参做专门的处理。  

## 变量作用域问题
在C语言中，关于变量的作用域，有如下规则：
- 语句块中定义的变量，作用域为本语句块中定义的部分到语句块的结束。  
- 语句块中定义的变量，在语句块之外不可见。  
- 语句块中，如果本语句块是外层语句块的一部分，那么外层语句块中的变量，本语句块中可以访问。  
- 不同语句块中，可以定义同名变量；这种情况下，访问变量时，优先使用本块内定义的变量，如果不存在则按照包含顺序，选择外层定义的同名变量。  

```
void func(int m) {
    if (m > 10) {
        int n = m * 10;
        if (n > 1000) {
            int k = 1;
            int m = 200; // 可以定义同名变量
            k = n + 1; // 外层定义的n这里可以访问
            k = k * m; // 这里的m，使用本语句块的定义
            ...
            // k的作用域到这里
        }
        // k = 10; // 编译错误，k在外层不可见。
        n = 200 * m; // 这里的m，本块中没有m的定义，使用外层定义的m
    }
}
```

为了实现这一规则，我们需要维护一棵变量树，具体如下：

- 变量树的节点Node，包括parent指针和该节点包含的变量集合vars。
- 每个语句块对应一个Node，该语句块定义的变量保存在该节点的vars中。
- 所有的全局变量同属一个Node（可以称为GlobalNode），该节点的parent指针为nullptr
- 函数参数和函数入口的语句块共用同一个Node，该Node的parent是上面的GlobalNode。
- 其他语句块，parent指向的是外层语句块对应的Node。

需要说明一下，这里的语句块和llvm::BasicBlock不是完全对应的。  
前端要按照自己对于语句块的划分（BlockAST）来构建变量树。  
针对语句块，在C语言中，除了按照上面的方式维护好变量之外，其他也没有什么要注意的。（如果是C++，还要注意调用对象的析构之类）

这样，在查找变量时，就可以按照parent指向一直查下去在，直到没有为止。  