
# 不变性
Clang的AST节点（类型，声明，语句，表达式等等）一般是创建后就不会再变的。这样有以下几个好处：
- 节点的"含义"可以创建时就进行规范化，并且不会被后续新增的信息影响。比如，我们规范化类型，使用一个规范的表达式形式来决定两包含了各自独立的表达式的函数模板，是否是代表同一个实体。
- AST节点可以复用。比如，我们复用类型节点来描述同一个类型（但是会给每一个类型写下的地方维护各自的TypeLoc信息），也会在模板实例化时复用Stmt和Expr节点。
- AST节点与AST文件之间进行序列化/反序列化更简单：我们不需要追踪AST节点的修改，也不用序列化单独的“更新记录”。

不过对这个一般化的目标，也有一些异常情况，比如：
- 对于一个多次声明的实体，第一个声明包含指向该实体最近的声明的指针。这个指针在分析出更多声明的时候需要跟着变。
- 在命名空间的声明构建之后，名字查找表需要跟着一起变。
- 我们设计上倾向于为一个模板的一个实例只生成一份声明，而不是根据定义的不同声明多次。那么模板实例化就会使得已经生成好的实例也跟着一起改变。
- 声明的一部分需要单独实例化（包括默认参数和异常特性化），这些实例化也会修改已经存在的声明。

这些情况比较零散；应该尽量避免出现可变的AST。  
作为设计原则的一个结果，我们尽量不提供AST state的set接口（有一些情况需要提供：在AST节点创建之后，"publish"作为完整AST的一部分之前立即修改，或者语法要求的时候）。

# 忠实性
AST会提供初始源代码的一个忠实表达。尽量只会用AST内部的或者再次构建信息来进行Refactor。这就要求AST表达不能解语法糖，也不能因为更清楚的表达而对代码进行解wrap。  
例如，CXXForRangeStmt 直接表达成一个range方式的语句，也包含range和迭代器相关的声明。但是不包含解语法糖之后的for语句。  
一些AST节点（比如ParenExpr）只包含语法信息，另一些（比如ImplicitCasrExpr）只包含语义信息；但是绝大多数的节点都是同时包含语法和语义信息。继承就是用来表达语法不同（但是相关）而语义相同的节点。  

# Type类和子类
Type类是AST的一个重要部分。Type对象通过ASTContext类访问，会在需要的时候隐式创建唯一类型信息。Type有一些不言自明的特性：1) Type不包含type修饰符，比如const，volatie等（参考QualType）2) type隐式包含typdef信息。Type创建之后就不可变了（与声明不同）。  
C语言中的typedef信息的存在略微增加了语义分析的复杂程度。问题在于，我们希望能捕获typedef信息，以便于在AST中优雅的表达出来，但是语法操作需要“贯穿“所有的typedef信息。比如下面的代码：
```
void func() {
  typedef int foo;
  foo X, *Y;
  typedef foo *bar;
  bar Z;
  *X; // error
  **Y; // error
  **Z; // error
}
```
上面的代码不能通过编译，然后，我们希望在我们注释的地方可以出现错误诊断信息。本示例中，我们想看到如下信息：
```
test.c:6:1: error: indirection requires pointer operand ('foo' invalid)
  *X; // error
  ^~
test.c:7:1: error: indirection requires pointer operand ('foo' invalid)
  **Y; // error
  ^~~
test.c:8:1: error: indirection requires pointer operand ('foo' invalid)
  **Z; // error
  ^~~
```
这个示例看起来有点“傻”，不过主要是说明一点：我们希望保留typedef信息，那么我们可以生成std::string的错误而不是std::basic_string<char, std::......>的错误。如果要做到这一点，就需要适当的维持typedef信息（比如，知道X的type是foo，而不是int），并且也能适当的扩展到不同的操作符中（比如，知道*Y的类型是foo, 不是int）。为了保持这些信息，这类表达式由TypedefClass类的实例来描述，该实例用来说明这类表达式是一个针对foo类型的typedef。  
使用这种方式表达一个类型，对于错误诊断帮助很大，因为一般用户自定义的类型往往都是能最容易感知的。不过这里还有2个问题：需要使用不同的语法检查来跳过typedef信息，判断type对应的真实类型；需要一种高效的方式来跳过typedef信息，判定2个类型是否结构上完全一致。这两个问题可以通过公认类型的思想解决。  
