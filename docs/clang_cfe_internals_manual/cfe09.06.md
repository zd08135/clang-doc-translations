ASTImporter类将AST节点从一个ASTContext导入另一个。可参考文档[ASTImporter: ](https://releases.llvm.org/15.0.0/tools/clang/docs/LibASTImporter.html)和import算法描述了解更多信息。

## 抽象语法图
和名字不同，Clang的AST并不是一个真的树，而是带回路的有向图。有向图的一个示例是ClassTemplateDecl与其模板实例化后的CXXRecordDecl。实例化之后的CXXRecordDecl描述了该类模板的成员和方法，ClassTemplateDecl则记录了模板相关的信息，比如，模板参数等。ClassTemplateDecl::getTemplatedDecl()可以获得实例化的CXXRecordDecl类，CXXRecordDecl::getDescribedTemplate()反过来可以获得其所实例化的模板类；所以这两个模板与实例的节点之间就存在一个回路。AST中也存在其他不同的回路。

## 结构等效性
导入AST节点的操作，会将节点整个复制到目标ASTContext中。复制这个操作指我们会在目标的Context中创建一个新节点，并且设置其属性和源节点相等。在复制之前，必须保证源节点和目标Context中的已存在节点之间没有结构等效性；如果有的话，那么复制就没有区别，就跳过复制。
结构等效性的正式定义：两个AST节点满足以下条件时可以认为是结构等效的。
- 同为内置类型，且类型相同（比如int和int是结构等效的）
- 同为函数类型，所有参数结构等效
- 同为记录类型（struct/class之类），其所有字段按定义顺序，标识符名字一致，且类型为结构等效。
- 变量或者函数声明，标识符名字一致，类型结构等效。

在C语言中，如果两个类型是compatible的，那么他们是结构等效的。C++标准中没有compatible的概念。这里我们拓展了结构等效的定义来处理模板和其实例化的场景：除了检查前述属性，还需要检查模板形参/实参的等效性。  
结构等效性检查逻辑可以（并且目前是）独立于ASTImporter，换句话说，clang::Sema也在使用之。  
节点之间的等效性有时会依赖于其他节点间的等效性，实现上，这个检查是在沿着图的边并发执行的。同时在图的不同节点上遍历，实际上采用的是类似BFS的实现。比如，我们要计算<A,B>的等效性，然后如果计算过程中走到了计算<X,Y>的话，那么说明：
- A和X是来自同一个ASTContext
- B和Y是来自同一个ASTContext
- A和B不一定来自同一个ASTContext
- 如果A == X 且 B == y（指针相同），那么（出现了回路）：A和B结构等效 <=> 从<A,B>到<X,Y>过程的所有节点都是结构等效的。

比较两个类或者枚举，而其中一个是未完成的，或者包含未完全加载的外部字面声明，那么就不能退一步只比较已包含的声明。这种情况下，我们就认为他们是否等效，取决于名字是否一样。这也是我们比较定义的前向声明的方式。  
（注：代码中，如果一个定义的提前声明出现了2次，那么可以认为这两个声明一样的，即结构等效的）

## 二次声明链
低版本的ASTImporter的合并机制会合并声明信息，即，其尝试只保留一个声明，而不是维持一个二次声明链。这个目标是想简单跳过函数原型而直接导入函数定义。这里举例来说明这个目标的问题，考虑一个空的目标context，以及下面这个源context中的virtual函数声明：     
```c
struct B { virtual void f(); };
void B::f() {} // <-- let's import this definition
```
如果直接合并掉声明信息，直接导入定义。那么，导入的结果就是一个实际为定义的声明，但是声明的isVirtual()方法就会返回false，原因是这个定义本身不是virtual的，而是函数原型的属性。  
为了解决这个问题，要么就给这个定义设置virtual相关的flag（但这样就等于创建一个不应该被创建的AST），要么就是将函数的整个二次生命链导入。新版本的ASTImporter采用了后者，按照在源context中的顺序，导入所有的函数声明，不管是定义还是原型。  
如果在目标context中已存在一个定义，那么就不能导入新的定义，而是使用现有的定义。不过我们可以导入原型：将新的原型链到现有的定义后面；不管什么时候，只要导入了一个新的原型，就会将该原型加到二次声明链后面，那么在一些特定场景下，可能会导致很长的声明链，比如，从多个不同的TU中，导入了包含相同头文件的原型。   
为了减少长链带来的影响，可以比较原型是否相同并进行合并。  
声明链的工作方式使得在复制时，会复制来自源AST的所有信息。尽管如此，有一个关于成员函数的问题：对于“自由”函数的原型可以很多个，但是类成员函数的原型只能有一个。
```c
void f(); // OK
void f(); // OK

struct X {
  void f(); // OK
  void f(); // ERROR
};
void X::f() {} // OK
```
所以，类成员函数的原型必须要合并，不能简单将新的原型链到已有的类中的原型上。考虑下面的上下文：
```c
// "to" context
struct X {
  void f(); // D0
};

// "from" context
struct X {
  void f(); // D1
};
void X::f() {} // D2
```
当我们从源context中导入f的原型和定义时，得到的声明链像这样：D0 -> D2'，D2'是D2的一个拷贝。  
一般情况下，在导入声明时（比如枚举和类），会将新导入到声明添加到已存在的声明链之后（如果他们是结构等效的）。但是，并不会和处理函数一样，将所有的调用链都导入。截至目前，我们并未看到在前向声明中，出现其他和成员函数的virtual标记类似的情况，不过未来也许会有变化。  

## 导入过程的遍历
节点相关的导入机制在ASTNodeImporter::VisitNode()相关函数中实现，比如VisitFunctionDecl()。在导入声明时，首先会导入用于调用该节点的构建器所需要的信息，所有需要后续设置的值在节点被创建之后设置。比如，针对FunctionDecl的情况，首先需要导入其声明所在的声明上下文，然后创建FunctionDecl这个类，再之后才导入函数的实现。这说明，在AST节点之前实际存在隐式的依赖关系；这些依赖关系决定我们从源头中按照何种顺序访问节点。实现中，按照常规图遍历算法（比如DFS）的思想，导入时会在ASTImporter::ImportedDecls中记录已经访问过的节点，创建新节点时，会直接加入到ImportedDecls中，只有在将新节点加入之后，才能处理新的声明的导入，否则会没法处理循环依赖的情况。为了强制保证按照上面的顺序执行，所有的AST节点的构造器都会被包装在GetImportedOrCreateDecl()。这个包装器保证新创建的节点会立马被标记为已导入；另一方面，如果一个声明被标记为已导入，那么就直接返回该声明在目标context中的对应节点。所以，直接调用一个声明的::Create()方法会导致错误，不允许这么做。  
即便使用了GetImportedOrCreateDecl()，如果导入方式错误，也可能出现导入无限递归的情况。考虑导入A时，导入B需要先于A的创建之前执行（A的构造器可能依赖B的引用），然后导入B也依赖A的先执行。为了保证针对模板的场景，也可以跳出循环依赖，需要一些额外的关注：只有在CXXRecordDecl创建之后，才能标记为该模板已被实例化。实践中，在目标上下文中创建节点之前，需要防止导入A的构造器不需要的节点。  

## 错误处理
每个导入的函数要么返回一个llvm::Error，要么返回一个llvm::Expected<T>对象。这样写强制调用者去检查导入函数的返回值。如果在导入过程中出错，就返回错误。（特殊情况：在导入类的成员时，会收集每个成员各自的错误，并且拼接到一个Error对象中）在处理声明时，会先缓存住这些错误。处理下一个导入的调用时，就会返回这些错误。这样，使用这些库的客户端就会拿到一个Error对象，而它们必须对其进行处理。  
在导入一个特定声明时，可能出现在识别到错误之前，已经提前创建了若干个AST节点。这种情况下，错误会返回给调用者，但是这些“脏”节点会保留在目标上下文中。理想状况下是不应该有这样的节点的，但是可能在创建节点时，还并没发现错误，而是之后的过程中才出现错误的。因为AST节点是不可变的（大部分情况是为了防止已存在节点被删除），会将这些节点标记为错误。  
源context中声明关联的错误会记录在ASTImporter::ImportDeclErrors中，目标context的声明关联错误记录在ASTImporterSharedState::ImportErrors中。注意，可能有一些ASTImporter对象会从不同的源上下文中导入到同一个目标上下文，这种情况下，他们会共享目标上下文中的关联错误。  
错误出现时，会在调用栈，和所有依赖节点上传播。目前会尝试将接地那标记为错误，方便客户端处理，而这无法处理有循环依赖的情。针对循环依赖，必须要记录该回路上的所有节点的错误信息。
导入路径是调用导入方法时，访问节点的列表。如果A依赖B，那么路径中会记录一条边A->B，从导入函数的调用链中可以看到基本一致的路径。
考虑下面的AST，->表示导入的依赖关系（所有的节点都是声明）
> 注：下图中还包含了B->E，通过文字表示不太明显
```c
A->B->C->D
   \->E
```
我们希望导入A。导入过程使用DFS思想，我们按照ABCDE的顺序访问。访问过程中，可能会出现如下的导入路径
```c
A
AB
ABC
ABCD
ABC
AB
ABE
AB
A
```
如果访问E的时候出现了错误，那么我们对E设置一个错误，然后缩到对B，再到对A
```c
A
AB
ABC
ABCD
ABC
AB
ABE // Error! Set an error to E
AB  // Set an error to B
A   // Set an error to A
```
不过，因为导入CD时并没有错误，CD也是和AB独立的，那么就不能对CD设置错误。那么，在导入结束时，ImportDeclErrors包含了对ABE的错误，不包含CD。

现在处理一下循环依赖的情况，考虑下面的AST
> 注：下图中还包含了B->E，通过文字表示不太明显
```c
A->B->C->D
   \->E
```
在访问过程中，如果E有错误，则会有下面的导入路径，ABE都被设置为错误，但是C怎么处理。
```c
A
AB
ABC
ABCA
ABC
AB
ABE // Error! Set an error to E
AB  // Set an error to B
A   // Set an error to A
```
这里，BC都依赖A，这就说明我们也必须对C设置错误。如果从调用栈回溯的话，A被设置成错误，而依赖A的节点也要设置错误，但是出错时，C并不在这个导入路径上，C是之前被加入过。这个场景只有访问出现循环时才会遇到。如果没有循环，常规的方法是把Error对象传递给调用栈上层。所以这就是每一次声明访问中出现的循环都要记录的原因。  

## 查找问题
从源上下文导入声明时，需要检查在目标上下文中是否存在名义相同，且结构等效的节点。如果源上下文的节点是一个定义，目标中找到的也是一个定义，那么就不在目标上下文中创建新的节点，而是标记目标上下文中的节点为已导入。如果找到的定义和源上下文中的定义名字一样，但是不是结构等效的，那么（C++的话）就会出现一个违反ODR的错误。如果源节点不是定义，就将其添加到目标节点的二次声明链。这个行为在合并包含相同头文件的不同TU对应的AST时很有必要。比如，（注：同一个类型）我们希望只存在一个std::vector的定义，即便在多个TU中都包含了\<vector\>头文件。  
为了找到一个结构等效的节点，可使用常规的C/C++查找函数：DeclContext::noload_lookup()和DeclContext::localUncachedLookup()。这些函数遵循C/C++的名字隐藏的原则，一些特定的声明在声明上下文是无法找到的，比如unamed声明（匿名结构体），非第一次出现的友元声明，模板特化等。这个问题可能导致如果支持常规的C/C++的查找，在合并AST时，会创建冗余的节点，冗余的节点又会导致在节点间结构等效型判定时出错。因为上面这些原因，创建一个查找类，专门用于注册所有的声明，这样这些声明就在导入之后，就可以被查找了。这个类叫：ASTImporterLookupTable。这个查找表会在导入同一个目标上下文的不同ASTImporter之间共享。这也是说明只能通过ASTImporterSharedState进行导入相关查询的原因。

### ExternalASTSource
ExternalASTSource是和ASTContext关联的抽象接口。它提供了通过迭代或者名字查找来访问声明上下文中的声明的能力。依赖外部AST的声明上下文需要按需加载其声明信息。这就说明（在未加载时）声明的列表（保存在链表中，头是DeclContext::FirstDecl）可能是空的，不过类似DeclContext::lookup()的成员函数可能会初始化加载流程。  
一般来讲，外部源代码是和预编译头文件相关的。比如，如果从预编译头文件中加载一个类，那么该类的成员只有在需要在该类的上下文中进行查找时才会被加载。  
考虑LLDB的情况，一个ExternalASTSource接口的实现类，是和对应表达式所在的AST上下文相关联的。这个实现是通过ASTImporter被发现的。通过这种方式，LLDB可以复用Clang的分析机制来从调试数据（比如DWARF，调试信息存储格式）中合成底层的AST。从ASTImporter的角度看，这意味着源和目标上下文中，可能包含存储了外部词法信息的声明上下文。如果目标上下文中的DeclContext对象包含了外部词法信息的存储，就必须特殊处理已经被加载的声明信息。否则，导入过程会变得不可控。比如，使用常规的DeclContext::lookup()在目标上下文中查找存在的声明，在导入声明的过程中，lookup方法会出现递归调用从而导致出现新的导入操作。（在初始化一个尚未注册的查找时，已经开始从源上下文中导入了）所以这里需要用DeclContext::noload_lookup()来代替。

## 类模板的实例化
不同的TU可能各自包含对相同模板参数的实例化，但是实例化后的MethodDecl和FieldDecl集合是不同的。考虑如下文件：
```c
// x.h
template <typename T>
struct X {
    int a{0}; // FieldDecl with InitListExpr
    X(char) : a(3) {}     // (1)
    X(int) {}             // (2)
};

// foo.cpp
void foo() {
    // ClassTemplateSpec with ctor (1): FieldDecl without InitlistExpr
    X<char> xc('c');
}

// bar.cpp
void bar() {
    // ClassTemplateSpec with ctor (2): FieldDecl WITH InitlistExpr
    X<char> xc(1);
}
```

在foo.cpp中，使用了(1)这个构造器，显式将a初始化为3，那么InitListExpr {0}这个初始化表达式就没被使用，也没有实例化相关的AST节点。然后，在bar.cpp中，我们使用了(2)这个构造器，没有使用初始化a的构造器，那么就会执行默认的InitListExpr并实例化。在合并foo.cpp和bar.cpp的AST时，就必须为X\<char\>这个模板实例化创建全部所需的节点。也就是说，如果找到了ClassTemplateSpecializationDecl对象，就需要把源上下文中，ClassTemplateSpecializationDecl对象的所有字段采用这个方式合并：如果一个InitListExpr不存在就复制。这个机制也适用于默认参数和异常规格的实例化。  

## 声明可见性
在导入外部可见的全局变量时，查找过程会找到同名变量，但是却是静态可见的。明确一下，就是不能把他们放到同一个二次声明链中。这个情况对函数也适用。而且，还需要特殊注意匿名命名空间的枚举、类。那么，我们会在查找结果中过滤，只考虑和当前导入的声明具有相同可见性的结果。  
这里认为，匿名命名空间的两个变量，只有来源于同一个源AST上下文的才认为是可见性相同的。  

## 冲突名字的处理策略
导入过程中，我们会查找是否存在有同名的声明，并且根据其可见性进行过滤。如果找到了声明，并且和源中的不是结构等效的，那么就报一个名字冲突的错误（C++中的ODR违规）。在此场景中，会返回Error对象并且将这个对象设置到声明中。不过，一些调用ASTImporter的客户端可能会要求不同的处理方式，比如不需要太保守的，更自由一点的错误处理策略。  
比如，代码的静态分析的客户端，会倾向于即便出现名字冲突时也创建节点。对进行特定工程进行CTU(Cross Translation Unit)分析时，必须知道可能存在全局的声明和来自其他TU的声明冲突，但是这些全局声明并不被本TU外部引用的情况。理想情况，这一部分声明需要放在匿名命名空间中。如果我们比较自由的处理这类冲突，那么CTU分析可以发现更多的结果。注意，支持选择不同的名字冲突处理策略的特性还尚未完善。
