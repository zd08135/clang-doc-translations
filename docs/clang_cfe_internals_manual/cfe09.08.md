在Clang前端中，有一些场景下，常量和常量折叠是很重要的。首先，通常情况下，希望能让AST尽可能贴近源代码。如果代码中写了“5+4”，我们希望在AST描述这两个常量的加法操作，而不是直接折叠成“9”。所以，不同方式处理常量折叠，其最终会通过树遍历的方式来实现，从而可以处理不同的场景。
> 注：5+4在AST中，会通过5,+,4三个AST节点表示，所以5+4的处理需要树的遍历）。  

不过，有一些场景是要求C/C++必须进行常量折叠的。举例，C标准以很精细、特殊化的方式定义了“整数常量表达式(i-c-e)”。语言中很多场景有需要i-c-e（比如bitfield的大小，case语句的值等），这样就必须进行常量折叠来进行语义检查（比如，判断bitfield的长度是否非负，case语句没有重复）。希望Clang可以很“教条”的方式处理：诊断出需要使用i-c-e而没有使用的场景，但是只有在使用-pedantic-errors时才报错，否则都通过编译。  
为了兼容真实世界的代码，需要有一点取巧的方式。考虑一种特殊情况，gcc的某个历史版本，会接受一个巨大的表达式超集作为i-c-e，然后，很多真实世界的代码都依赖这个不太幸运的特性（包括比如glibc的头文件）。gcc会将任何能被折叠成一个整数常量的都进行该优化。比如，gcc会将case X-X语句优化成case 0，即便x是一个变量。  
另一个问题是，常量是如何和编译器支持的扩展交互的，比如__builtin_constant_p, __builtin_inf, __extension__和其他的。C99没有明确指定这些扩展的语义，i-c-e的定义也没有包含这些。不过，在实际开发时，这些扩展经常会用到，所以必须有合适的方式处理。  
最后，这不仅仅是关于语义分析的问题。代码生成器和其他的客户端也需要具备常量折叠的能力（比如，初始化全局变量），也必须处理C99规定的超集。而且，这些客户端会从扩展中受益。比如，我们知道foo() || 1的计算结果一定是true，但是因为有边际效应，就不能直接替代成true。

> 关于上面的gcc历史版本的特性说明：  
> gcc在4.x版本中，出现过过度“折叠”优化，导致正常的计算出现错误的情况。比如这个bug：  
> <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57829>  
> 这些内容不在本文的范围内，这里只是提一下。  

## 实现目标
在尝试过多个不同的目标之后，最终综合出了一个设计（注意，编写本文时，不是所有的都被实现了，这一部分是一个设计目标！）。最基本的目标是定义一个简单的递归计算方法（Expr::Evaluate），在AST/ExprConstant.cpp中实现。给定一个“标量"类型（比如整数，浮点，复数，指针）的表达式，这个方法会返回下面的信息：  
- 此表达式是否为i-c-e/一个没有副作用的通用常量/一个有副作用的通用常量/一个不可计算或折叠的值
- 这个表达式是否是可以计算的，（如果可以计算）此方法会返回APValue代表计算结果
- 如果这个表达式不能执行，这个方法会返回表达式中所存在的其中一个问题。信息中还包括描述问题位置的SourceLocation，以及解释该问题的诊断ID。这个诊断具有EXTENSION类型。

> 副作用：这里指常量折叠中用到的表达式可能产生的附加影响。比如下面的代码：
> ```
> int x = 3;
> int retConstant() {
>   x = 4;
>   return 5;
> }
>
> int func() {
>   int y = 3 * retConstant();
>   return y;
> }
> ```
> 这里不能直接将y或者func()的调用折叠成15，否则x = 4就不会执行，从而导致程序错误。  

这些信息可以为客户端提供所需的一些灵活性，最终也会有针对不同扩展的辅助方法。比如，Sema类需要有一个Sema::VerifyIntegerConstantExpression方法，这个方法调用了Evaluate。如果这个表达式不能折叠，就报告一个错误，然后返回true。如果这个表达不是i-c-e，这个EXTENSION诊断就报告出来。最后，如果AST没问题的话就返回false。  
其他的客户端可以通过不同的方式使用这些信息，比如，代码生成可以直接使用折叠后的结果。  

## 扩展
本节描述一下Clang在常量计算时支持的不同的扩展：
- `__extension__`：这个表达式会尝试将可以被计算的子表达式替换成i-c-e。
- __builtin_constant_p：这个方法在操作数可以被计算为一个整数、浮点、复数的数字值（而不是指针转换成整形），或者是否是某个字符串首字母的地址（会转换成其他类型）时返回true。特殊例子，如果__builtin_constant_p 是（被自动加了括号）条件操作表达式的条件，那么只有为真的那一部分被考虑，也被折叠。
- __builtin_choose_expr：这个情况
- __builtin_classify_type: 这个一定会返回一个i-c-e
- __builtin_inf, nan, ...: 这些被看成是浮点数常量
- __builtin_abs, copysign, ...: 按照通用的常量表达式处理常量折叠
- __builtin_strlen 和 strlen: 参数为字符串字面常量时，按照i-c-e处理常量折叠