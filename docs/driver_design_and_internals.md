
# 基本说明

## 源码地址

参考llvm github:  
<https://github.com/llvm/llvm-project.git>  
<https://gitee.com/mirrors/LLVM.git>  （github地址的国内镜像，每日同步）  

## 版本选择

基于clang11版本文档翻译  
<https://releases.llvm.org/11.0.0/tools/clang/docs/DriverInternals.html>

选择11.0版本的代码，具体版本如下：

```
commit 1fdec59bffc11ae37eb51a1b9869f0696bfd5312 (HEAD, tag: llvmorg-11.1.0-rc3, tag: llvmorg-11.1.0, origin/release/11.x)
Author: Andi-Bogdan Postelnicu <abpostelnicu@me.com>
Date:   Wed Feb 3 17:38:49 2021 +0000

    [lldb] Fix fallout caused by D89156 on 11.0.1 for MacOS

    Fix fallout caused by D89156 on 11.0.1 for MacOS

    Differential Revision: https://reviews.llvm.org/D95683
```
## 平台

本文的中的附加内容需要实际开发运行的部分，相关的开发调试主要基于Linux平台(Ubuntu/Fedora/CentOS）  
推荐使用VSCode作为IDE开发：<https://code.visualstudio.com/>

## 备注

本文中的引用是本人自己添加的，不是原文的翻译。
> 这段文字是我添加的内容
> ```
> 这段代码是我添加的内容
> ```

TODO: **未来可能会按照clang版本形式，将本文档也划分成不同版本**  
FIXME: **文中出现的其他链接，部分会链接到llvm docs的原始网站，如果未来对应文档也有翻译的话，会同步修正为本书内部的链接。**

# ---以下为正文---

# 介绍

本文档描述了Clang的驱动器，主要目的是描述驱动器的产生的动机以及设计目标，也包括内部实现的细节解释。

# 特性和目标

Clang驱动器期望是成为可以用于实际生产的高质量的编译器驱动器。Clang驱动通过和gcc驱动器兼容的命令行方式，提供了对Clang编译器和工具的访问能力。  
尽管此驱动器属于Clang项目的一部分，并且由Clang项目推进；在逻辑上，它是一个和Clang有很多共同目标的独立工具。

## GCC兼容性

Clang驱动设计的第一号目标，就是可以让用户可以更容易地去接受将Clang应用到原本被设计使用GCC的构建系统。尽管这会使驱动比起需求会更加复杂；但是让驱动在命令行接口上和gcc一致仍然值得这么做，因为这样可以让用户更快速的在其项目中进行测试。

## 灵活性

驱动设计上很灵活，在clang和LLVM架构增长时，很容易纳入新的用法。比如，驱动器可以很容易为引入已集成汇编器的工具添加支持，这个特性希望未来LLVM也能具备。

出于同样考虑，大部分的驱动的能力都是通过库提供的。这些库可以用来构建其他实现或者提供gcc相似的接口的工具。

## 低开销

驱动本身应该是开销越低越好。实践中发现，gcc的驱动自身在编译很多小文件时，会带来很少但是也不能忽视的开销。
比起编译过程来讲，驱动的工作不多，但是仍然需要通过一些原则使其尽量高效：

- 尽可能避免字符串的分配与复制
- 参数只解析一次
- 为高效查询的参数提供一些简单接口

> 第三点是说：编译命令可能会有N多参数；可以提供一些接口支持高效的查询，比如提供接口，输入参数的名字就可以直接定位内容之类。

## 保持简单

最后，在满足其他目标的前提下，这个驱动的设计应该尽量简单。需要注意到，尝试兼容gcc驱动这个目标会带来巨大的复杂性。不过，驱动的设计会通过将整个流程划分成若干个独立阶段，避免耦合成一整块任务的方式减少复杂程度。

# 内核设计与实现

## 内核介绍

为了实现上面提到的目标，驱动设计上可以完整包含gcc的能力，也就是说，不应该再委托gcc来完成细粒度的任务。
在Darwin中，Clang驱动器会进一步包含gcc驱动器的功能，来支持构建通用镜像（二进制和目标文件）能力。这也需要驱动器可以直接调用语言相关的编译器（比如cc1），也就是说，驱动必须记录足够的信息来将参数正确转发给子进程。

## 设计总览

下图展示了驱动架构中的重要组件和相互关系。橙色部分代表驱动创建的具体的数据结构，绿色部分指明操作这些数据结构的概念上独立的阶段，蓝色部分是一些重要的辅助类。



## 驱动阶段



